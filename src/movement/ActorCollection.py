import json

from src.city.ZoneType import ZoneType
from src.common.CommonFunctions import CommonFunctions
from src.common.FemtocellLoader import FemtocellLoader
from src.common.Location import Location
from src.movement.LocationsTable import LocationsTable
from src.movement.movementStrategies.MovementStrategyFactory import MovementStrategyFactory
from src.movement.movementStrategies.MovementStrategyType import MovementStrategyType
from src.placeable.movable.Drone import Drone
from src.placeable.movable.Movable import Movable
from src.placeable.movable.MovementActivity import MovementActivity
from src.placeable.movable.MovementActivityType import MovementActivityType
from src.placeable.movable.Person import Person
from src.movement.LocationPredictor import LocationPredictor
from random import randint
from datetime import datetime
from src.common.SimulationClock import *
import time

from src.common.MacrocellLoader import MacrocellLoader
from src.placeable.stationary.Attractor import Attractor


class ActorCollection:

    def __init__(self, name, map, ableOfMovement, movementStrategy, mapGrid, secondsPerTick):
        self.name = name
        self.map = map
        self.ableOfMovement = ableOfMovement
        self.locationsTable = LocationsTable(mapGrid)
        self.actorSet = {}
        self.mapGrid = mapGrid
        self.secondsPerTick = secondsPerTick
        self.movementStrategy = MovementStrategyFactory().getStrategy(movementStrategy, self.locationsTable,
                                                                      self.actorSet, self.map, self.mapGrid)
        self.attractors = []
        self.guiEnabled = False
        self.com = CommonFunctions()

    def setGuiEnabled(self, value: bool) -> 'ActorCollection':
        self.guiEnabled = value
        return self

    def step(self, newDay: bool):
        # print("step_ New day:", newDay)
        # print(self.locationsTable.getTable())
        if (newDay):
            for key, movable in self.actorSet.items():
                self.movementStrategy.onDayChange(movable)
        self.attractorEffects()
        for id in self.locationsTable.getIdsInDestinations():
            walkable: object = self.actorSet[int(id)]


            # if agent has no MovementActivity in queue, it is needed to create some
            # print(f"walkable with id: {id} is in destination {walkable.getLocation().toJson()}")
            # print("Size of its activity queue is: ", len(walkable.activityQueue))
            if walkable.getCurrentMovementActivity() == None:
                # route will be obtained from movement activity
                locationRoute = self.movementStrategy.getNewRoute(walkable)
                # print("Actor has no activity, so we create one using route: ", locationRoute)
                # for location in locationRoute:
                #     print(f"{location.toJson()}")
                destination = locationRoute[-1]
                # print("movement destination will be: ", destination.toJson())
                activity = MovementActivity(
                    destination=destination,
                    startTime=None,
                    endTime=None,
                    importance=0,
                    name="generated by StepNew",
                    type=MovementActivityType.REGULAR_ACTIVITY,
                    routePlanningRequired=False  # no need, because we route will be assigned in next step
                )
                # assignment of route to the freshly created activity
                activity.route = locationRoute
                # print("New activity is:", activity.toJson())
                # activity is appended to the queue of agent
                walkable.appendMovementActivity(activity)

            # First activity is obtained from agents queue
            activity = walkable.getCurrentMovementActivity()
            # print("ACTOR HAS ACTIVITY:", activity.toJson())
            if activity.getStarted():
                # if current activity is already started, its location route is used to plan target location
                # but first we need to check whether route planning should be performed
                # print("it even started!")
                if activity.getRoutePlanningRequired():
                    # print("But planning is required")
                    activity.route = self.movementStrategy.getRouteTo(walkable, activity.getDestination())
                    activity.setRoutePlanningRequired(False)
                    # print("thus new route will be:", activity.route)
                # else:
                # print("Planning was not required")
                targetLocation = activity.getNextLoctionFromRouteAndPopIt()
                if (targetLocation == None):
                    raise ValueError('TargetLocation is None')
                walkable.setTargetLocation(targetLocation)
                walkable.setTargetReached(False)
                # print("Target location was changed to:", walkable.getTargetLocation().toJson(), " and target reached is False")
            else:
            #     # if activity not yet started, agent should stay at current possition
                # print("But activity is not activated yet")
                walkable.setTargetRerached(False)

            # print("Decision about removal of activity: ", activity.toJson())
            if activity.routeEmpty() and activity.getFinished():
                # if route of current activity is empty, and activity finish time passed, activity can be removed
                # print("Removing activity!")
                walkable.removeFirstActivity()
                # print("AfterRemoval")
                # for acti in walkable.activityQueue:
                #     print(acti.toJson())

        # all agents in collection should have destinations configured now, we can move them using movements strategy
        # move method
        self.movementStrategy.move()

    def getLocationPredictionsForNextIterations(self, nuOfIterations, movementBackwardsAllowed=True):
        """
        This method returns possible locations of agent moving along routes
        !NOTE! that this method should be called right afer step() method
        :param nuOfIterations:
        :return: dictionary of lists with LocationPrediction objects
        """

        if (self.movementStrategy.strategyType not in [MovementStrategyType.RANDOM_INTERSECTION_WAYPOINT_CITY_CUDA]):
            raise ValueError('Location prediction is not available for collection with set MovementStrategyType:',
                             self.movementStrategy.strategyType)
        if (movementBackwardsAllowed == False):
            raise ValueError(
                'You required prediction that will ignore ability to move backwards, but mobility pattern may allow it')

        for actorId in self.locationsTable.getAllIds():
            walkable: Movable = self.actorSet[int(actorId)]
            # destination == node of open street map
            # update is done to find out which walkables are located at intersection nodes
            isAtIntersection = self.map.isIntersection(walkable.getLocation())
            walkable.setIsAtIntersection(isAtIntersection)
        locationPredictor = LocationPredictor()
        return locationPredictor.predictLocationsForNextIterations(self.map, self.getActorsInDestinations(),
                                                                          self.actorSet, self.secondsPerTick,
                                                                          nuOfIterations, movementBackwardsAllowed)

    def addPlaceables(self, placeables) -> 'ActorCollection':
        """
        before using this method, Placeables need to have their locations set (same with speed for Movables)
        :param placeables: list of Placeables that will be added to the actor set of ActorCollection
        :return: self
        """
        for placeable in placeables:
            self.actorSet[placeable.id] = placeable
        return self

    def addPersons(self, count, withInitialMove=False) -> 'ActorCollection':
        """
        adds persons to the simulation model with the random location within the simulated space
        @param count: number of persons to be added
        @param withInitialMove: True/False make steps in random direction to leave the initial location
        @return: no return value
        """
        for i in range(0, count):
            location = self.map.getRandomIntersectionNode()
            person = Person(self.locationsTable, self.map)
            person.tableRow = self.locationsTable.insertNewActor(person)
            person.setSpeed(2 * self.secondsPerTick)
            person.setMap(self.map)
            x, y = self.mapGrid.getGridCoordinates(location)
            location.setGridCoordinates(x, y)
            person.setLocation(location)
            person.home = location
            person.setTargetLocation(location)
            person.setTargetReached(True)
            if (self.movementStrategy.strategyType == MovementStrategyType.PERSON_BEHAVIOUR_CITY_CUDA):
                person.location = self.map.getRandomBuildingFromZoneType(ZoneType.HOUSING).getCentroid()
                person.work = self.map.getRandomBuildingFromZoneType(ZoneType.WORK).getCentroid()
                person.generateDailyActivityQueue()
            self.actorSet[person.id] = person
            person.setTargetReached(True)

        if withInitialMove:
            for key, person in self.actorSet.items():
                person.setSpeed(randint(0, 50))

            for i in range(0, 100):
                self.step()

            for key, person in self.actorSet.items():
                person.setSpeed(2 * self.secondsPerTick)

        return self

    def addDrones(self, count) -> 'ActorCollection':
        for i in range(0, count):
            location = self.map.getRandomPoint()
            location.setAltitude(10)
            x, y = self.mapGrid.getGridCoordinates(location)
            location.setGridCoordinates(x, y)
            drone = Drone(self.locationsTable, self.map)
            drone.tableRow = self.locationsTable.insertNewActor(drone)
            drone.setSpeed(2 * self.secondsPerTick)
            drone.setMap(self.map)
            drone.setLocation(location)
            drone.setTargetLocation(location)
            drone.setTargetReached(False)
            self.actorSet[drone.id] = drone
        return self

    def addAttractor(self, location: Location, radius, startTime, endtime) -> 'ActorCollection':
        location.setAltitude(0)
        x, y = self.mapGrid.getGridCoordinates(location)
        location.setGridCoordinates(x, y)
        attractor = Attractor(locationsTable=self.locationsTable, map=self.map, radius=radius, startTime=startTime,
                              endTime=endtime)
        attractor.tableRow = self.locationsTable.insertNewActor(attractor)
        attractor.setLocation(location)
        attractor.startTime = startTime
        attractor.endTime = endtime
        self.actorSet[attractor.id] = attractor
        return self

    def loadMacrocells(self, networks) -> 'ActorCollection':
        macrocellLoader = MacrocellLoader()
        macrocells = macrocellLoader.getMacrocells("147.232.40.82",
                                                   self.map.latitudeInterval[0],
                                                   self.map.latitudeInterval[1],
                                                   self.map.longitudeInterval[0],
                                                   self.map.longitudeInterval[1],
                                                   self.locationsTable,
                                                   self.map,
                                                   networks)
        for cell in macrocells:
            self.actorSet[cell.id] = cell
        return self

    def generateFemtocells(self, count, minRadius) -> 'ActorCollection':
        femtocellLoader = FemtocellLoader()
        femtocells = femtocellLoader.getFemtocells(self.locationsTable, self.map, count, minRadius)
        for cell in femtocells:
            self.actorSet[cell.id] = cell
        return self

    def storeFemtoCells(self, filename) -> 'ActorCollection':
        print("Actor set", self.actorSet)
        list = []
        for key, value in self.actorSet.items():
            list.append(value)
        femtocellLoader = FemtocellLoader()
        femtocellLoader.storePlaceablesLocationsIntoFile(list, filename)
        return self

    def loadFemtocellsFromFile(self, filename) -> 'ActorCollection':
        femtocellLoader = FemtocellLoader()
        femtocells = femtocellLoader.loadSmallCellsFromFile(self.locationsTable, self.map, filename)
        for cell in femtocells:
            self.actorSet[cell.id] = cell
        return self

    def getFeaturesGeoJson(self):
        features = []
        for key, movable in self.actorSet.items():
            features.append(movable.getGeoStruct())
        return features

    def getActorsAtIntersections(self):
        return list(map(self.actorSet.get, self.locationsTable.getIdsAtIntersections()))

    def getActorsInDestinations(self):
        return list(map(self.actorSet.get, self.locationsTable.getIdsInDestinations()))

    def logMovement(self, newDay) -> 'ActorCollection':
        for id in self.locationsTable.getIdsInDestinations():
            walkable = self.actorSet[int(id)]
            walkable.logLocation(newDay)
        return self

    def getMovablesAtGridXY(self, x, y):
        ids = self.locationsTable.getIdsAtGridXY(x, y)
        movables = []
        for id in ids:
            movables.append(self.actorSet[id])
        return movables

    def attractorEffects(self) -> 'ActorCollection':
        global DATETIME
        for attractor in self.attractors:
            if attractor.startTime <= getDateTime() <= attractor.endTime:
                usersInArea = self.mapGrid.getActorsInRadius(attractor.radius, [self.name], attractor.getLocation())
                for user in usersInArea:
                    if user.getCurrentMovementActivity() == None or \
                            ((
                                     not user.getCurrentMovementActivity().getType() == MovementActivityType.ATTRACTOR_ACTIVITY) and user.getCurrentMovementActivity().importance < attractor.severity):
                        attractorActivity = MovementActivity(
                            attractor.getLocation(),
                            startTime=None,
                            endTime=attractor.endTime,
                            importance=attractor.severity,
                            name=attractor.name,
                            routePlanningRequired=False,
                            type=MovementActivityType.ATTRACTOR_ACTIVITY
                        )
                        locationRoute = self.movementStrategy.getRouteTo(user, attractor.getLocation())
                        attractorActivity.pushLocationListToRoute(locationRoute)
                        user.storeMovementActivity(attractorActivity, asFirst=True)

        self.attractors[:] = (x for x in self.attractors if x.endTime > getDateTime())
        return self

    def compareCurrentLocationsWithPredictions(self, predictionDict):
        for id, actor in self.actorSet.items():
            dictKey = (actor.id, getDateTime().strftime("%m/%d/%Y, %H:%M:%S.%f"))

            if (dictKey in predictionDict):
                predictions = predictionDict[dictKey]

                correctPredictionFound = False
                for prediction in predictions:
                    if prediction.location.equlsWithLocation(actor.getLocation()):
                        print(
                            f"Correct!!! Current location {actor.getLocation().toJson()} of actor {actor.id} corresponds to the prediction {prediction.toJson()}")
                        correctPredictionFound = True
                        break
                    else:
                        print(f"Prediction: {prediction.toJson()}")
                        print(f"Current location {actor.getLocation().toJson()}")
                        print("Note this is not the right prediction!")
                if (correctPredictionFound == False):
                    print(
                        f"Error will follow but this might be interesting: {actor.getLocation().toJson()} is intersection: {self.map.isIntersection(actor.getLocation())}")
                    raise ValueError(f"Not found in predictions {actor.getLocation().toJson()} of actor {actor.id} ")
            else:
                print(f"dict key not even in prediction {dictKey}")

    # def saveLocationsFile(self) -> 'ActorCollection':
    #     locations = ""
    #     for key, person in self.actorSet.items():
    #         location = person.getLocation()
    #         locations = locations + str(location.getLatitude()) + ", " + str(location.getLongitude()) + ", \n"
    #     self.com.appendToFile("locationsDebug", locations)
    #     return self
